import json
import os
import sys
from typing import Dict, List, Optional
from pathlib import Path

# Adicionar o diret√≥rio raiz ao path para importar m√≥dulos
sys.path.append(str(Path(__file__).parent.parent.parent))

from utility.templates.template_manager import TemplateManager

class TemplateScriptGenerator:
    """Gerador de roteiro adaptativo baseado em templates"""
    
    def __init__(self):
        self.template_manager = TemplateManager()
        self.script_templates = {
            'cinematic_religious': {
                'intro_patterns': [
                    "Voc√™ n√£o vai acreditar no que j√° estava previsto h√° s√©culos.",
                    "Prepare-se para descobrir uma verdade chocante.",
                    "O que voc√™ est√° prestes a ver vai mudar tudo.",
                    "Uma profecia antiga est√° se cumprindo agora mesmo.",
                    "O que a B√≠blia previu est√° acontecendo diante dos nossos olhos."
                ],
                'development_patterns': [
                    "Em {topic} est√° escrito que",
                    "A {topic} revela que",
                    "Segundo a {topic},",
                    "A profecia sobre {topic} diz que",
                    "O que {topic} previu est√° acontecendo agora"
                ],
                'climax_patterns': [
                    "Agora pense comigo sobre isso.",
                    "Mas o que isso significa para n√≥s?",
                    "E se eu te disser que",
                    "O mais assustador √© que",
                    "E o pior ainda est√° por vir."
                ],
                'conclusion_patterns': [
                    "Ou ser√° que j√° estamos vivendo o in√≠cio dessa profecia?",
                    "Ser√° que voc√™ est√° preparado para essa verdade?",
                    "O que voc√™ vai fazer com essa informa√ß√£o?",
                    "Est√° na hora de acordar para a realidade.",
                    "A escolha √© sua: ignorar ou agir."
                ]
            }
        }
    
    def generate_script_for_template(self, topic: str, template_id: str) -> Dict:
        """Gera um roteiro espec√≠fico para um template"""
        print(f"üé¨ GERANDO ROTEIRO PARA TEMPLATE: {template_id}")
        print(f"üìù T√≥pico: {topic}")
        print("-" * 50)
        
        # Verificar se o template existe
        template = self.template_manager.get_template(template_id)
        if not template:
            return {'error': f'Template {template_id} n√£o encontrado'}
        
        # Gerar roteiro usando IA se poss√≠vel, sen√£o usar padr√µes
        script = self._generate_script_with_ai(topic, template_id)
        if not script:
            script = self._generate_script_from_patterns(topic, template_id)
        
        if not script:
            return {'error': 'N√£o foi poss√≠vel gerar o roteiro'}
        
        # Aplicar template ao roteiro gerado
        template_result = self.template_manager.apply_template_to_script(script, template_id)
        
        if 'error' in template_result:
            return template_result
        
        # Combinar resultados
        final_result = {
            'success': True,
            'template_id': template_id,
            'template_name': template.get('name'),
            'topic': topic,
            'script': script,
            'template_data': template_result,
            'estimated_duration': 45  # Dura√ß√£o estimada em segundos
        }
        
        print(f"‚úÖ Roteiro gerado com sucesso!")
        print(f"   ‚Ä¢ Template: {template.get('name')}")
        print(f"   ‚Ä¢ Dura√ß√£o estimada: {final_result['estimated_duration']}s")
        print(f"   ‚Ä¢ Palavras: {len(script.split())}")
        
        return final_result
    
    def _generate_script_with_ai(self, topic: str, template_id: str) -> str:
        """Gera roteiro usando IA (Groq/OpenAI)"""
        try:
            # Verificar se temos API key dispon√≠vel
            if not os.environ.get("GROQ_API_KEY") and not os.environ.get("OPENAI_KEY"):
                print("‚ö†Ô∏è Nenhuma API key dispon√≠vel, usando padr√µes")
                return ""
            
            # Importar m√≥dulo de script generator
            from utility.script.script_generator import generate_script
            
            # Gerar script base usando IA
            base_script = generate_script(topic)
            
            # Adaptar para o template espec√≠fico
            if template_id == 'cinematic_religious':
                adapted_script = self._adapt_for_religious_template(base_script, topic)
                return adapted_script
            
            return base_script
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar script com IA: {e}")
            return ""
    
    def _adapt_for_religious_template(self, base_script: str, topic: str) -> str:
        """Adapta script para template religioso/cinematogr√°fico"""
        # Remover frases muito gen√©ricas e adicionar tom dram√°tico
        dramatic_intro = "Voc√™ n√£o vai acreditar no que j√° estava previsto h√° s√©culos."
        
        # Extrair pontos principais do script base
        sentences = base_script.split('.')
        main_points = [s.strip() for s in sentences if len(s.strip()) > 20][:3]
        
        # Criar script dram√°tico
        dramatic_script = f"{dramatic_intro} {topic} revela verdades chocantes que est√£o acontecendo agora mesmo. "
        
        if main_points:
            dramatic_script += " ".join(main_points) + ". "
        
        dramatic_script += f"Mas o que isso significa para n√≥s? E se eu te disser que o que {topic} previu est√° se cumprindo diante dos nossos olhos? Ser√° que voc√™ est√° preparado para essa verdade? Ou ser√° que j√° estamos vivendo o in√≠cio dessa profecia?"
        
        return dramatic_script
    
    def _generate_script_from_patterns(self, topic: str, template_id: str) -> str:
        """Gera roteiro usando padr√µes pr√©-definidos"""
        if template_id not in self.script_templates:
            return ""
        
        patterns = self.script_templates[template_id]
        
        # Selecionar padr√µes baseados no t√≥pico
        import random
        
        intro = random.choice(patterns['intro_patterns'])
        development = random.choice(patterns['development_patterns']).format(topic=topic)
        climax = random.choice(patterns['climax_patterns'])
        conclusion = random.choice(patterns['conclusion_patterns'])
        
        # Criar roteiro completo mais din√¢mico
        script_parts = [
            intro,
            f"E agora est√° acontecendo bem diante dos nossos olhos.",
            f"{development} grandes mudan√ßas est√£o por vir.",
            f"O controle total est√° sendo implementado.",
            f"{climax}",
            f"O que voc√™ pensa sobre isso?",
            f"{conclusion}"
        ]
        
        return " ".join(script_parts)
    
    def _adjust_pauses_with_real_timestamps(self, pauses_strategy: Dict, audio_file_path: str) -> Dict:
        """Ajusta as pausas usando timestamps reais do √°udio via Whisper"""
        print(f"üéµ Analisando √°udio real para sincronizar pausas...")
        
        try:
            # Usar Whisper para obter timestamps reais
            from utility.captions.timed_captions_generator import generate_timed_captions
            
            # Gerar legendas com timestamps reais
            timed_captions = generate_timed_captions(audio_file_path)
            
            if not timed_captions:
                print("‚ö†Ô∏è N√£o foi poss√≠vel obter timestamps reais, usando estimativas")
                return self._adjust_pauses_for_duration(pauses_strategy, 45.0)
            
            # Calcular dura√ß√£o real baseada no √∫ltimo timestamp
            real_duration = max(t2 for (t1, t2), text in timed_captions)
            print(f"üìä Dura√ß√£o real do √°udio: {real_duration:.1f}s")
            
            # Mapear posi√ß√µes das pausas para timestamps reais
            adjusted_strategy = {}
            
            for pause_type, pauses in pauses_strategy.items():
                adjusted_pauses = []
                
                for pause in pauses:
                    original_position = pause.get('position', 0)
                    original_duration = pause.get('duration', 0)
                    
                    # Encontrar o timestamp mais pr√≥ximo da posi√ß√£o original
                    target_position = (original_position / 45.0) * real_duration
                    
                    # Encontrar o segmento de legenda mais pr√≥ximo
                    closest_segment = None
                    min_distance = float('inf')
                    
                    for (t1, t2), text in timed_captions:
                        segment_middle = (t1 + t2) / 2
                        distance = abs(segment_middle - target_position)
                        
                        if distance < min_distance:
                            min_distance = distance
                            closest_segment = (t1, t2)
                    
                    if closest_segment:
                        # Usar o final do segmento como posi√ß√£o da pausa
                        adjusted_position = closest_segment[1]
                        # Manter a dura√ß√£o proporcional
                        adjusted_duration = (original_duration / 45.0) * real_duration
                        
                        adjusted_pause = pause.copy()
                        adjusted_pause['position'] = adjusted_position
                        adjusted_pause['duration'] = adjusted_duration
                        adjusted_pause['original_position'] = original_position
                        adjusted_pause['real_segment'] = closest_segment
                        adjusted_pauses.append(adjusted_pause)
                        
                        print(f"   üéØ Pausa ajustada: {original_position:.1f}s ‚Üí {adjusted_position:.1f}s (segmento: {closest_segment[0]:.1f}s-{closest_segment[1]:.1f}s)")
                
                adjusted_strategy[pause_type] = adjusted_pauses
            
            return adjusted_strategy
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao analisar √°udio real: {e}")
            print("üîÑ Usando estimativas baseadas em dura√ß√£o...")
            return self._adjust_pauses_for_duration(pauses_strategy, 45.0)

    def generate_script_with_pauses(self, topic: str, template_id: str) -> Dict:
        """Gera roteiro com estrat√©gia de pausas aplicada"""
        print(f"üé¨ GERANDO ROTEIRO COM PAUSAS: {template_id}")
        print(f"üìù T√≥pico: {topic}")
        print("-" * 50)
        
        # Primeiro gerar o roteiro b√°sico
        result = self.generate_script_for_template(topic, template_id)
        if 'error' in result:
            return result
        
        # Obter estrat√©gia de pausas do template
        template = self.template_manager.get_template(template_id)
        pauses_strategy = template.get('pauses_strategy', {}) if template else {}
        
        if pauses_strategy:
            # Calcular dura√ß√£o estimada baseada no n√∫mero de palavras
            script = result.get('script', '')
            word_count = len(script.split())
            # Estimativa: ~3 palavras por segundo
            estimated_duration = word_count / 3.0
            
            # Ajustar pausas para a dura√ß√£o real
            adjusted_pauses = self._adjust_pauses_for_duration(pauses_strategy, estimated_duration)
            
            # Adicionar informa√ß√µes de pausas ao resultado
            result['pauses_strategy'] = adjusted_pauses
            result['pauses_applied'] = True
            result['estimated_duration'] = estimated_duration
            
            print(f"\n‚è±Ô∏è ESTRAT√âGIA DE PAUSAS APLICADA (Dura√ß√£o estimada: {estimated_duration:.1f}s):")
            for pause_type, pauses in adjusted_pauses.items():
                print(f"   ‚Ä¢ {pause_type}: {len(pauses)} pausas")
                for pause in pauses:
                    print(f"     - {pause.get('position', 0):.1f}s ({pause.get('duration', 0):.1f}s): {pause.get('description', '')}")
        else:
            print("‚ö†Ô∏è Nenhuma estrat√©gia de pausas encontrada para este template")
        
        return result
    
    def _adjust_pauses_for_duration(self, pauses_strategy: Dict, estimated_duration: float) -> Dict:
        """Ajusta as pausas para a dura√ß√£o real estimada do script (fallback)"""
        adjusted_strategy = {}
        
        for pause_type, pauses in pauses_strategy.items():
            adjusted_pauses = []
            for pause in pauses:
                # Calcular posi√ß√£o ajustada baseada na dura√ß√£o real
                original_position = pause.get('position', 0)
                original_duration = pause.get('duration', 0)
                
                # Assumir que as pausas originais s√£o baseadas em 45 segundos
                # Ajustar proporcionalmente para a dura√ß√£o real
                if estimated_duration > 0:
                    adjusted_position = (original_position / 45.0) * estimated_duration
                    adjusted_duration = (original_duration / 45.0) * estimated_duration
                else:
                    adjusted_position = original_position
                    adjusted_duration = original_duration
                
                adjusted_pause = pause.copy()
                adjusted_pause['position'] = adjusted_position
                adjusted_pause['duration'] = adjusted_duration
                adjusted_pauses.append(adjusted_pause)
            
            adjusted_strategy[pause_type] = adjusted_pauses
        
        return adjusted_strategy
    
    def validate_template_assets(self, template_id: str) -> Dict:
        """Valida se todos os assets necess√°rios para o template est√£o dispon√≠veis"""
        print(f"üîç VALIDANDO ASSETS DO TEMPLATE: {template_id}")
        print("-" * 40)
        
        template = self.template_manager.get_template(template_id)
        if not template:
            return {'error': f'Template {template_id} n√£o encontrado'}
        
        missing_assets = {
            'audio_effects': [],
            'video_effects': [],
            'background_music': []
        }
        
        # Verificar assets em cada se√ß√£o
        sections = template.get('sections', {})
        for section_name, section_data in sections.items():
            assets = section_data.get('assets', {})
            
            # Verificar efeitos de √°udio
            for effect in assets.get('audio_effects', []):
                if not os.path.exists(effect):
                    missing_assets['audio_effects'].append(effect)
            
            # Verificar efeitos de v√≠deo
            for effect in assets.get('video_effects', []):
                if not os.path.exists(effect):
                    missing_assets['video_effects'].append(effect)
            
            # Verificar m√∫sica de fundo
            bg_music = assets.get('background_music', '')
            if bg_music and not os.path.exists(bg_music):
                missing_assets['background_music'].append(bg_music)
        
        total_missing = sum(len(assets) for assets in missing_assets.values())
        
        if total_missing == 0:
            print("‚úÖ Todos os assets est√£o dispon√≠veis!")
            return {'success': True, 'missing_assets': missing_assets}
        else:
            print(f"‚ö†Ô∏è {total_missing} assets faltando:")
            for asset_type, missing in missing_assets.items():
                if missing:
                    print(f"   ‚Ä¢ {asset_type}: {len(missing)} arquivos")
                    for asset in missing[:3]:  # Mostrar apenas os primeiros 3
                        print(f"     - {asset}")
                    if len(missing) > 3:
                        print(f"     ... e mais {len(missing) - 3} arquivos")
            
            return {'success': False, 'missing_assets': missing_assets}
    
    def get_template_suggestions(self, topic: str) -> List[Dict]:
        """Sugere templates apropriados para um t√≥pico"""
        templates = self.template_manager.list_templates()
        suggestions = []
        
        # An√°lise simples baseada em palavras-chave
        topic_lower = topic.lower()
        
        for template in templates:
            score = 0
            reasons = []
            
            # Verificar se √© conte√∫do religioso/b√≠blico
            if any(word in topic_lower for word in ['b√≠blico', 'religioso', 'profecia', 'apocalipse', 'deus', 'jesus', 'b√≠blia']):
                if 'religioso' in template['name'].lower() or 'cinematogr√°fico' in template['name'].lower():
                    score += 3
                    reasons.append("Conte√∫do religioso detectado")
            
            # Verificar se √© conte√∫do educativo/curioso
            if any(word in topic_lower for word in ['curioso', 'interessante', 'fato', 'descoberta', 'ci√™ncia', 'hist√≥ria']):
                if 'curioso' in template['name'].lower() or 'fatos' in template['name'].lower():
                    score += 2
                    reasons.append("Conte√∫do educativo detectado")
            
            if score > 0:
                suggestions.append({
                    'template_id': template['id'],
                    'name': template['name'],
                    'description': template['description'],
                    'score': score,
                    'reasons': reasons
                })
        
        # Ordenar por score
        suggestions.sort(key=lambda x: x['score'], reverse=True)
        
        return suggestions
    
    def generate_with_suggestions(self, topic: str) -> Dict:
        """Gera roteiro com sugest√£o autom√°tica de template"""
        print(f"üéØ GERANDO ROTEIRO COM SUGEST√ïES")
        print(f"üìù T√≥pico: {topic}")
        print("-" * 50)
        
        # Obter sugest√µes de templates
        suggestions = self.get_template_suggestions(topic)
        
        if not suggestions:
            return {'error': 'Nenhum template apropriado encontrado para o t√≥pico'}
        
        # Usar o template com maior score
        best_template = suggestions[0]
        print(f"üé® Template sugerido: {best_template['name']} (Score: {best_template['score']})")
        
        # Gerar roteiro com o template sugerido
        return self.generate_script_with_pauses(topic, best_template['template_id'])

def main():
    """Teste do TemplateScriptGenerator"""
    print("üé¨ TESTE DO TEMPLATE SCRIPT GENERATOR")
    print("="*60)
    
    generator = TemplateScriptGenerator()
    
    # Testar gera√ß√£o de script
    print("\nüìù TESTANDO GERA√á√ÉO DE SCRIPT:")
    result = generator.generate_script_with_pauses("profecia b√≠blica do apocalipse", "cinematic_religious")
    
    if 'error' not in result:
        print(f"‚úÖ Script gerado com sucesso!")
        print(f"   ‚Ä¢ Template: {result['template_name']}")
        print(f"   ‚Ä¢ Palavras: {len(result['script'].split())}")
        print(f"   ‚Ä¢ Pausas aplicadas: {result.get('pauses_applied', False)}")
        print(f"\nüìÑ Script:")
        print(f"   {result['script'][:200]}...")
    else:
        print(f"‚ùå Erro: {result['error']}")
    
    # Testar valida√ß√£o de assets
    print("\nüîç TESTANDO VALIDA√á√ÉO DE ASSETS:")
    validation = generator.validate_template_assets("cinematic_religious")
    if 'error' not in validation:
        print(f"   ‚Ä¢ Sucesso: {validation['success']}")
        if not validation['success']:
            print(f"   ‚Ä¢ Assets faltando: {sum(len(assets) for assets in validation['missing_assets'].values())}")
    else:
        print(f"   ‚ùå Erro: {validation['error']}")
    
    # Testar sugest√µes
    print("\nüéØ TESTANDO SUGEST√ïES:")
    suggestions = generator.get_template_suggestions("profecia b√≠blica do apocalipse")
    for suggestion in suggestions:
        print(f"   ‚Ä¢ {suggestion['name']} (Score: {suggestion['score']})")
        for reason in suggestion['reasons']:
            print(f"     - {reason}")

if __name__ == "__main__":
    main() 